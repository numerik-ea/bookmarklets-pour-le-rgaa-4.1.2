javascript:(function showTextInNonSemanticTags() { const textNodes = []; const walker = document.createTreeWalker( document.body, NodeFilter.SHOW_TEXT, null, false ); let node; while (node = walker.nextNode()) { textNodes.push(node); } const textNodesInNonSemanticTags = []; const semanticTags = [ 'P', 'LI', 'A', 'BUTTON', 'LABEL', 'OPTION', 'TEXTAREA', 'INPUT', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'FIGCAPTION', 'LEGEND', 'CAPTION', 'TD', 'TH', 'DT', 'DD', 'BLOCKQUOTE', 'Q' ]; const semanticRoles = { 'heading': ['1', '2', '3', '4', '5', '6'] }; const tagsToIgnore = [ 'SCRIPT', 'STYLE', 'META', 'LINK', 'NOSCRIPT', 'COMMENT' ]; textNodes.forEach(textNode => { let content = textNode.textContent; content = content.trim(); if (content === '') { return; } let parent = textNode.parentElement; let isInSemanticElement = false; let isInIgnoredTag = false; while (parent) { if (semanticTags.includes(parent.tagName)) { isInSemanticElement = true; break; } const role = parent.getAttribute && parent.getAttribute('role'); if (role === 'heading') { const ariaLevel = parent.getAttribute('aria-level'); if (semanticRoles.heading.includes(ariaLevel)) { isInSemanticElement = true; break; } } if (role === 'button') { isInSemanticElement = true; break; } if (tagsToIgnore.includes(parent.tagName)) { isInIgnoredTag = true; break; } parent = parent.parentElement; } if (!isInSemanticElement && !isInIgnoredTag) { textNodesInNonSemanticTags.push(textNode); } }); const counttextNodesInNonSemanticTags = textNodesInNonSemanticTags.length; if (counttextNodesInNonSemanticTags === 0) { alert('Pas de texte dans des balises non sémantiques.'); return; } let message = ( counttextNodesInNonSemanticTags + ' textes dans des balises non sémantiques' ); if (counttextNodesInNonSemanticTags === 1) { message = message.replace('textes dans des balises non sémantiques', 'texte dans une balise non sémantique'); } alert(message + '.\nPlus de détails dans la console.'); console.clear(); console.log(message + ' :'); function checkForHiddenParents(element) { const hiddenParents = []; let currentElement = element; while (currentElement && currentElement !== document.body && currentElement !== document.documentElement) { const computedStyle = window.getComputedStyle(currentElement); const isHidden = computedStyle.display === 'none' || computedStyle.visibility === 'hidden' || computedStyle.opacity === '0' || (computedStyle.height === '0px' && computedStyle.width === '0px') || currentElement.getAttribute('aria-hidden') === 'true'; if (isHidden) { hiddenParents.push({ element: currentElement, reason: getHiddenReason(currentElement, computedStyle) }); } currentElement = currentElement.parentElement; } return hiddenParents; } function getHiddenReason(element, computedStyle) { const reasons = []; if (computedStyle.display === 'none') reasons.push('display: none'); if (computedStyle.visibility === 'hidden') reasons.push('visibility: hidden'); if (computedStyle.opacity === '0') reasons.push('opacity: 0'); if (computedStyle.height === '0px' && computedStyle.width === '0px') reasons.push('height: 0 and width: 0'); if (element.getAttribute('aria-hidden') === 'true') reasons.push('aria-hidden="true"'); return reasons.join(', '); } textNodesInNonSemanticTags.forEach(textNode => { const parentElement = textNode.parentElement; if (parentElement) { parentElement.style.border = '2px solid red'; parentElement.style.paddingTop = '26px'; parentElement.style.display = 'block'; const label = document.createElement('div'); label.textContent = 'texte non sémantique'; label.style.position = 'absolute'; label.style.top = '0'; label.style.left = '0'; label.style.backgroundColor = 'yellow'; label.style.color = 'black'; label.style.padding = '2px 5px'; label.style.fontSize = '12px'; label.style.fontWeight = 'bold'; label.style.zIndex = '10000'; label.style.pointerEvents = 'none'; const computedStyle = window.getComputedStyle(parentElement); if (computedStyle.position === 'static') { parentElement.style.position = 'relative'; } parentElement.appendChild(label); const hiddenParents = checkForHiddenParents(parentElement); if (hiddenParents.length > 0) { console.log('⚠️ Texte dans une balise non sémantique ayant des parents cachés :'); console.log(textNode); hiddenParents.forEach((hiddenParent, index) => { console.log(` Parent caché ${index + 1} :`, hiddenParent.element, `(Raison: ${hiddenParent.reason})`); }); return; } } console.log(textNode); }); })();