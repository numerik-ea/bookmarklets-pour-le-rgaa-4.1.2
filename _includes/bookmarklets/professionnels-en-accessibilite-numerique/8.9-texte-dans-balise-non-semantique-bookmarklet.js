javascript:(function showTextInNonSemanticTags() { function getAllShadowRoots(root = document) { const shadowRoots = []; const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT); let node; while ((node = walker.nextNode())) { if (node.shadowRoot) { shadowRoots.push(node.shadowRoot); shadowRoots.push(...getAllShadowRoots(node.shadowRoot)); } } return shadowRoots; } const allRoots = [document.body, ...getAllShadowRoots()]; const shadowRootCount = allRoots.length - 1; const textNodes = []; allRoots.forEach((root) => { const walker = document.createTreeWalker( root, NodeFilter.SHOW_TEXT, null, false ); let node; while ((node = walker.nextNode())) { textNodes.push(node); } }); const textNodesInNonSemanticTags = []; const semanticTags = [ 'P', 'LI', 'A', 'BUTTON', 'LABEL', 'OPTION', 'TEXTAREA', 'INPUT', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'FIGCAPTION', 'LEGEND', 'CAPTION', 'TD', 'TH', 'DT', 'DD', 'BLOCKQUOTE', 'Q', 'TIME', ]; const semanticRoles = { heading: ['1', '2', '3', '4', '5', '6'], }; const tagsToIgnore = [ 'SCRIPT', 'STYLE', 'META', 'LINK', 'NOSCRIPT', 'COMMENT', ]; textNodes.forEach((textNode) => { let content = textNode.textContent; content = content.trim(); if (content === '') { return; } let parent = textNode.parentElement; let isInSemanticElement = false; let isInIgnoredTag = false; let root = textNode.getRootNode(); while (parent) { if (semanticTags.includes(parent.tagName)) { isInSemanticElement = true; break; } const role = parent.getAttribute && parent.getAttribute('role'); if (role === 'heading') { const ariaLevel = parent.getAttribute('aria-level'); if (semanticRoles.heading.includes(ariaLevel)) { isInSemanticElement = true; break; } } if (role === 'button') { isInSemanticElement = true; break; } if (tagsToIgnore.includes(parent.tagName)) { isInIgnoredTag = true; break; } const nextParent = parent.parentElement; if (!nextParent && root instanceof ShadowRoot) { const host = root.host; if (host) { parent = host; root = host.getRootNode(); continue; } break; } parent = nextParent; } if (!isInSemanticElement && !isInIgnoredTag) { textNodesInNonSemanticTags.push(textNode); } }); const counttextNodesInNonSemanticTags = textNodesInNonSemanticTags.length; if (counttextNodesInNonSemanticTags === 0) { alert('Pas de texte dans des balises non sémantiques.'); return; } const elementsInDocument = []; const docTextNodes = []; const docWalker = document.createTreeWalker( document.body, NodeFilter.SHOW_TEXT, null, false ); let docNode; while ((docNode = docWalker.nextNode())) { docTextNodes.push(docNode); } docTextNodes.forEach((textNode) => { let content = textNode.textContent.trim(); if (content === '') { return; } let parent = textNode.parentElement; let isInSemanticElement = false; let isInIgnoredTag = false; while (parent) { if (semanticTags.includes(parent.tagName)) { isInSemanticElement = true; break; } const role = parent.getAttribute && parent.getAttribute('role'); if (role === 'heading') { const ariaLevel = parent.getAttribute('aria-level'); if (semanticRoles.heading.includes(ariaLevel)) { isInSemanticElement = true; break; } } if (role === 'button') { isInSemanticElement = true; break; } if (tagsToIgnore.includes(parent.tagName)) { isInIgnoredTag = true; break; } parent = parent.parentElement; } if (!isInSemanticElement && !isInIgnoredTag) { elementsInDocument.push(textNode); } }); const elementsInShadow = textNodesInNonSemanticTags.filter( (el) => !elementsInDocument.includes(el) ); let message = counttextNodesInNonSemanticTags + ' textes dans des balises non sémantiques'; if (counttextNodesInNonSemanticTags === 1) { message = message.replace( 'textes dans des balises non sémantiques', 'texte dans une balise non sémantique' ); } const locationParts = []; if (elementsInDocument.length > 0) { locationParts.push(`${elementsInDocument.length} dans le document`); } if (elementsInShadow.length > 0) { locationParts.push(`${elementsInShadow.length} dans shadow DOM`); } if (locationParts.length > 0) { message += ` (${locationParts.join(', ')})`; } if (shadowRootCount > 0) { message += `\n${shadowRootCount} shadow root(s) analysé(s).`; } alert(message + '.\nPlus de détails dans la console.'); console.clear(); console.log(message + ' :'); allRoots.forEach((root, index) => { const rootName = index === 0 ? 'Document principal' : `Shadow root ${index}`; const rootTextNodes = []; const rootWalker = document.createTreeWalker( root, NodeFilter.SHOW_TEXT, null, false ); let rootNode; while ((rootNode = rootWalker.nextNode())) { rootTextNodes.push(rootNode); } const rootTextNodesInNonSemanticTags = []; rootTextNodes.forEach((textNode) => { let content = textNode.textContent.trim(); if (content === '') { return; } let parent = textNode.parentElement; let isInSemanticElement = false; let isInIgnoredTag = false; let nodeRoot = textNode.getRootNode(); while (parent) { if (semanticTags.includes(parent.tagName)) { isInSemanticElement = true; break; } const role = parent.getAttribute && parent.getAttribute('role'); if (role === 'heading') { const ariaLevel = parent.getAttribute('aria-level'); if (semanticRoles.heading.includes(ariaLevel)) { isInSemanticElement = true; break; } } if (role === 'button') { isInSemanticElement = true; break; } if (tagsToIgnore.includes(parent.tagName)) { isInIgnoredTag = true; break; } const nextParent = parent.parentElement; if (!nextParent && nodeRoot instanceof ShadowRoot) { const host = nodeRoot.host; if (host) { parent = host; nodeRoot = host.getRootNode(); continue; } break; } parent = nextParent; } if (!isInSemanticElement && !isInIgnoredTag) { rootTextNodesInNonSemanticTags.push(textNode); } }); if (rootTextNodesInNonSemanticTags.length > 0) { console.log(`\n${rootName}:`); rootTextNodesInNonSemanticTags.forEach((textNode) => console.log(textNode) ); } }); function checkForHiddenParents(element) { const hiddenParents = []; let currentElement = element; let root = element.getRootNode(); while ( currentElement && currentElement !== document.body && currentElement !== document.documentElement ) { const computedStyle = window.getComputedStyle(currentElement); const isHidden = computedStyle.display === 'none' || computedStyle.visibility === 'hidden' || computedStyle.opacity === '0' || (computedStyle.height === '0px' && computedStyle.width === '0px') || currentElement.getAttribute('aria-hidden') === 'true'; if (isHidden) { hiddenParents.push({ element: currentElement, reason: getHiddenReason(currentElement, computedStyle), }); } let parent = currentElement.parentElement; if (!parent && root instanceof ShadowRoot) { const host = root.host; if (host) { currentElement = host; root = host.getRootNode(); continue; } break; } currentElement = parent; } return hiddenParents; } function getHiddenReason(element, computedStyle) { const reasons = []; if (computedStyle.display === 'none') reasons.push('display: none'); if (computedStyle.visibility === 'hidden') reasons.push('visibility: hidden'); if (computedStyle.opacity === '0') reasons.push('opacity: 0'); if (computedStyle.height === '0px' && computedStyle.width === '0px') reasons.push('height: 0 and width: 0'); if (element.getAttribute('aria-hidden') === 'true') reasons.push('aria-hidden="true"'); return reasons.join(', '); } textNodesInNonSemanticTags.forEach((textNode) => { const parentElement = textNode.parentElement; if (parentElement) { parentElement.style.border = '2px solid red'; parentElement.style.paddingTop = '26px'; parentElement.style.display = 'block'; const label = document.createElement('div'); label.textContent = 'texte non sémantique'; label.style.position = 'absolute'; label.style.top = '0'; label.style.left = '0'; label.style.backgroundColor = 'yellow'; label.style.color = 'black'; label.style.padding = '2px 5px'; label.style.fontSize = '12px'; label.style.fontWeight = 'bold'; label.style.zIndex = '10000'; label.style.pointerEvents = 'none'; const computedStyle = window.getComputedStyle(parentElement); if (computedStyle.position === 'static') { parentElement.style.position = 'relative'; } parentElement.appendChild(label); const hiddenParents = checkForHiddenParents(parentElement); if (hiddenParents.length > 0) { console.log( '⚠️ Texte dans une balise non sémantique ayant des parents cachés :' ); console.log(textNode); hiddenParents.forEach((hiddenParent, index) => { console.log( ` Parent caché ${index + 1} :`, hiddenParent.element, `(Raison: ${hiddenParent.reason})` ); }); return; } } console.log(textNode); }); })();